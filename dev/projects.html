<br>

<h2>Fly</h2>
<p>A silly little flight-sim project.</p>
<br>
<video width="100%" controls style="margin-bottom:-4px;">
  <source src="vid/flightsimsorta.mp4"/>
</video>
<br>
<p>Each surface is simulated, togethe forming the flight characteristics of the airplane as a whole. Can you spot the small square under the rudder? That was added, because otherwise the plane (with its flat planes :P) would have zero drag.</p><!--p>causing it to go extremely fast despite a very weak (invisible) engine. IIRC the thrust/mass-ratio is .25 or something like that, where the mass is calculated using the total wing-area, and depth at just One.</p-->



<br><br>

<h2>Minesweeper</h2>

<img src="img/sweep.gif" >
<p>It's Minesweeper. It's a small enough game that you can enjoy the entire creation process.
  There's not much more to say about it other than "I had fun making it" and "I suck at playing it". :P  </p>

<br><br>




<!--img src="img/bridge2.gif" -->
<h2>The Playstation Project</h2>
<p>With this project, my goal is to create a software renderer and game engine, complete with physics and animations, using only <b>fixed-point arithmetic</b> instead of <b>floating-point</b>. In terms of rendering capabilities, it's much in line with the original Playstation. The main target platform is the Raspberry Pi (Gen1/Zero) and Desktop PC.</p>



<!--img src="https://cdn.discordapp.com/attachments/304776287841419264/577125472161497115/metroidprime.gif"-->

<video width="100%" controls style="margin-bottom:-4px;">
  <source src="vid/ps1_fps_vid4.mp4"/>
</video>
<br>

<!--img src="img/rakdohl.gif" -->
<!--i><p>It has been sort of a slow project. I work on it every now and then. Many parts of the engine have been rewritten over and over. I'm tempted to rewrite much of the physics yet again, despite it working well enough for any game I would try to make with this engine. (The constrain solver is not so great) :P </p></i-->


<!--img src="img/cycle1.gif" -->
<br>
<h2H>Features</h2H>
<ul type="bullet" class="List">
	<li>1 MiB pretend-VRAM, for screen-buffers, color look-up tables and textures.</li>

<li><i>Gouraud-shaded affine-textured triangle rasterization</i> There are also <i>untextured</i> and <i>flat-shaded</i> modes.</li>
<li><i>4x4 Matrix-dithering</i>, to reduce color banding (and more importantly, to make things look distinctly "PS1").</li>

<li><i>Blending-modes</i>, including <i>Add, Multiply</i> and <i>Mix 50%</i>.</li>

<li>Primitive subdivision (to make the affine textures look better up close).</li>

<li>Painter's algorithm, primitive-sorting using bucket-lists, is used instead of <i>Z-buffering</i>.</li>

<li>Texture LOD (level of detail), to reduce flickering (and theoretically improve performance, but there isn't much of a difference on a modern computer when the biggest texture is 256x256 and uses only 4-bits per pixel).</li>

<li>Fog (by "fogging" the CLUTs instead of doing it per pixel)</li>

<li>Skeletal animation playback</li>

<li>Particles and decals</li>


<li>Rigid body physics and fast enough <i>broad-phase collision</i> using <i>spatial-partitioning</i>. Also, ray-intersection against "everything", and various other useful functions for physics queries.</li>
</ul>


<video width="100%" controls style="margin-bottom:-4px;">
  <source src="vid/ps1_fps_vid3.mp4"/>
</video>
<br>

<img src="img/ps1_shot.png">
<br>

<img src="img/ps1_char.png" >
<i><p>A very low poly character.</i></p>
<!--img src="img/ps1_anim.gif" --!>
<p> Each vertex is tied to only one joint, so no weight painting or anything like that. There are few enough vertices that just interpolating vertex keyframes wouldn't take up a ton of memory, but since I want to be able to add inverse kinematics and other effects on the bones later, I'll stick to skeletal animation. One idea would be to mix the two kinds, where things like hands and facial expressions are vertex-animated, while the overall pose is skeletal. But it's unlikely I'll have time for that amount of detail.</p></i>

<br>


<img src="img/subdiv.gif" >
<i><p>Subdivision in action.</p></i>

<img src="img/rbtorn.gif" >
<i><p>Some physics happening. The depth image in the lower-right corner is a ray intersection test, the brightness of a pixel indicates how far a ray have traveled before its first hit.</p></i>
<br><br>
<!--img src="img/rtxon.gif" >
<i><p>A ray-intersection test where the grey image in the corner is rendered using rays beamed against the geometry.</p></i-->

<!--h2>Playground</h2>
<h2H>-for physics, animation, pathfinding etc.</h2H>
<p>Have you ever thought to yourself: <i>Where did I put that code I once wrote for this similar problem?</i></p>

<p>This is exactly what this project is for. Rewriting something a second time is good for memorization, and it's neat keeping all the new tricks I pick up in one place, as opposed to have them scattered over 20 different project. (I can think of other solutions to this problem, like having organized repositories and tackling different subjects with a more API-like approach. But I'm not much of a code-reuser. For some things, yes, but not many.</p>

<p>So this has been an ongoing parallel project to almost all of my other projects. For instance, when working on some ray-intersection test for my Playstaion project, I'll also poke around with the same problem in this much less restricted format. Or, when I learn something from another project, I'll be quick to update the code here. It's not just physics, but also animation and AI. I don't have any plans for this beyond using it's a playground of learning, and a useful thing for future and current projects.</p>

<img src="img/gjk1.gif">
<p>Depicted:<i>My early stages of figuring out GJK (Gilbert-Johnson-Keerthi closest point).</i> The basics of the algorithm wasn't so diffictult to grasp (in fact I had been aware of the concept for years before attempting to implement it myself), but figuring out how to extract the closest points and a normals upon intersection, definitely was.</p-->

 <br><br>

<!--h2>DOS project</h2>

<p>I've spent some time on a DOS-project but I haven't gotten far. It's been interesting learning more about legendary CPU's like the i386, and about x86-assembly. I can't write about this project without mentioning my friend <a href="https://twitter.com/64Mega">64mega</a>, who have been showing me the ropes around dosdev.</p>
<img src="img/akdos.gif" >
<p>The jerkiness of the animation in this gif is due to me being lazy and using a X.7 fixed-point matrix for the rotation. The default integer on DOS is 16-bits wide, so two unit matrices multiplied above that precision would overflow. As soon as I get back to DOS-dev, I'll just increase precision to X.12, and I'll put (long) in front of any operation in risk of overflowing. Or perhaps I'll write some fixed-point math routines for that in assembly. Or perhaps I'll just use floating-point. We'll see.</p>
<br>

-->

<br>

<!--h2>Abandoned Software Rendering Project</h2>
<br>
<img src="img/srfps.jpg" >

<br>
<p>This was my previous software rendering project, also written in C, inspired by old DOS games such as Quake or Doom ( except I have an i7, not an i486 ). It uses a 16-bit framebuffer (rather than 256-colors) and no Z-buffer. Perspective correction is performed at the start and end of each row of pixels within a triangle, and if needed, at every 16th pixel within the row. Pretty much the way Quake did it, except mine was completetly fixed-point. For no good reason; Quake used floating-point operations. (FDIV every 16th pixel, which the FPU could perform while the pixels were being filled in = much faster. ) Anyhow, I abandoned this to go for the true 256-color DOS project shown above, and the separate 16-bit color Playstation-project.</p>


<img src="old_site/cycle2.gif" >
<br>
<br>

<img src="img/cycle1.gif" >
<br>
<br -->


<br>


<h2>Raspberry Pi Project</h2>
<p>In 2016 I tried to make a game for Raspberry Pi Zero/Gen1. The engine was written using C++(98) and openGL ES2.0. It had shadowmapping, normalmapping, joint-animations and a bunch of other features.</p>

<img src="old_site/cade.jpg">
<img src="old_site/sonic_spoof.jpg">


<br>
<br>
<br>

<div class="btn" onclick="projects.toggle()">hide</div>

<br>
<br>
<br>


