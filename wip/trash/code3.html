<h1>Programming</h1>

<p>This page attempts to summarize me as a programmer. First off, to get it out of the way; the languages, tools and environments I use regularly:</p> 

<h3>Languages I use regularly</h3>
<p>
<ul>
  <li>C</li>
  <li>C++</li>
  <li>Python</li>
  <li>JavaScript</li>
  <li>Lua</li>
</ul>

<h3>Other tools</h3>
<ul>
  <li>Emacs</li>
  <li>Visual Studio</li>
  <li>GNU Compiler Collection</li>
  <li>CMake</li>
  <li>Git (but not religiously)</li>
  <li>Bash</li>
</ul>

<h3>Libraries (C)</h3>
<ul>
  <li>OpenGL</li>
  <li>OpenAL</li>
  <li>GLFW</li>
  <li>Various Single Header Files</li>
</ul>


<h3>Lowly beginnings</h3>
<p>I started out with <b>C++</b>, which felt like the only viable option in 2008 for making games. Soon after, I discovered the source code for Doom and other games written in <b>C</b>, which lead me to learn that language as well.
 <br>&emsp;Needless to say, video games have been a big driver for me to learn programming. I wanted to understand them on a low and high, as well as artistic, level. 
  Uncovering the mysteries and inner workings of games, and implementing a lot of it in my own games, has been a true joy.</p>

<p>To this day I still remain mostly on the low-level end of things. I want to know what's going with the hardware, what system-calls are being made, how much memory is used and what libraries are used. That the software I release is ballpark reasonable in terms of performance, in relation to the work that is being done. <br>&emsp;I like to work with a minimal set of dependencies, and prefer not to rely on big binary blobs or black boxes where I have no way of knowing what may be causing a problem.</p>
<p>But, I don't treat all projects the same and write plenty of code in a less pedantic way.</p>

<p>I write C and C++ in a similar way. Some might call my C++ "orthodox". I like arrays and simple structs. I'm not afraid of raw pointers, but I also like it when things are trivially copyable (without serialization etc). I use inheritance in moderation, and yes I am a fan of Data-Orient Design. There is much more to write about this, but I'll save it for a different page as this one is meant to be a quick overview, not deep dives.</p>

<h3>Higher level</h3>
<p>I don't need to explain the usefulness of <b>Python</b> and <b>JavaScript</b>. I'm not an expert on any of them, but I do use them a lot. JavaScript for anything that runs in a browser. Python mostly in combination with Blender 3D, for custom tools and plugins, but sometimes in for pure math/problem-solving situations.</p>

<h3>Big Soft Inc</h3>
<p>I've made games with <b>Java</b> and <b>C#</b>, but honestly I don't have much to say about these languages.<br>&emsp;
My biggest weakness as a programmer is probably my lack of experience working with a bigger team. I can see the value for a team in using a language that enforce a coding-style and prevents direct memory access etc., but for me as a lone coder, I don't run into the same complexity.<br>&emsp;
Sometimes I do run into some trouble as my code grows. I will say that I miss type-safety in Python.</p> 


<h3>Whatever is useful</h3>
<p>I'm not very opioninatad when it comes to the syntax of a language or coding styles. I think the problem at hand is the important part, the logic, the algorithm, whatever it is, not the syntax.<br>&emsp;As long as a language meets the basic requirements, and I've learned enough of the syntax to be able to use it, I'm a happy coder.</p>



<h3>Math, Algorithms, Abstract Types and Data-Structures</h3>
<p>These topics are, IMO, more interesting than any individual language. 



Learning how to use one new abstract type can just one new algorithm can be more powerful than learning an entirely new programming language.</p>
<p>


  This is were the real action happens, as long as it's in the end packaged in a form that is executable on a machine.</p>
<p>

<h3>Math</h3>
<p>I don't have a background in Math, but I've picked up a lot of Linear Algebra making 3D games, and some Calculus. Enough to write my own 3D physics engines at least.</p>
in may ways much more interesting in I'm genuinely interested in knowing what's going on with the software, and the limitations of the hardware.</p>

<h3>Algorithms</h3>
<p>I've studied and implemented various algorithms related to game-AI, rendering and collision detection, such as GJK, Bresnham, Dijkstra, A*, Median-Cut, Cohen-Sutherland and Sutherland-Hodgman. I've also implemented many abstract types using various data-structures in C and C++.</p>

<1-- TODO: link some code, add algorithms section ?? -->

<!-- h3>Optimization</h3>
<p>Sometimes I'll spend an unreasonably long time optimizing some part of a program that really doesn't need it. I'm fully aware of the Knuth quote, but to me this is a fun part of programming; making thigs go fast. It's also great for learning more about how fast things *should* be able to run and what the computer is capable of.</p>

<p>It is true that you can easily lock yourself in by prematurely optimize code, 

 yourself in. via 

<p>I'm a big fan of Data-Oriented Design. I al


<p>Hopefully by know you have at least some idea of what type of programmer I am.</p>



<p>II think it would be better 

and what to avoid in the future, it it's easiliy avoidable. I think a lot of the performance problems I encounter in software I use on a daily basis, is because no one even cared to do the minimal amount of trying to make it go fast.</p>

<p>



issues we encounter 


 (or I'll just open up my favorite file, <i>ape.cpp</i>). I'll rewrite the same thing over and over, only to throw the results away and go back to the original. Because, it's interesting and fun, because I want to try things out, or because I want to practice. I don't think the ambition to write better and faster code is <i>evil</i>.<br>
  <span style="padding-left:1.8em"/>Yes, I can agree with the famous Knuth quote to some degree. Early optimizations that cause your code to become less nimble and harder to read, are likely "evil". It also easy to waste time if you're trying to write optimal code for something you don't understand yet. But planning for good performance early on is not a bad idea. What are the things that need to happen in order for us to be able to work on this piece of software, in a manageable way, yet ensure that it won't end up as an incredibly sluggish final product? Those ad-hoc last-minute optimizations may not be enough.

-->


<!--
<h3>Algorithms</h3>
<p>I've studied and implemented various algorithms related to game-AI, rendering and collision detection, such as GJK, Bresnham, Dijkstra, A*, K-means, Cohen-Sutherland and Sutherland-Hodgman, and I've implemented a bunch of abstract types using various 
  
etc. As well as various abstract types and data structures such as Binary-Heaps, Linked-Lists, Bucket-Lists, BSPs and Octrees. Data structures are great, but nine times out of ten, I'll just use the array (and quite often, that's the best option).</p>

<br>
<h3>Optimization</h3>
<p>Sometimes I'll "waste" my time optimizing some part of a program that really doesn't need it (or I'll just open up my favorite file, <i>ape.cpp</i>). I'll rewrite the same thing over and over, only to throw the results away and go back to the original. Because, it's interesting and fun, because I want to try things out, or because I want to practice. I don't think the ambition to write better and faster code is <i>evil</i>.<br>
  <span style="padding-left:1.8em"/>Yes, I can agree with the famous Knuth quote to some degree. Early optimizations that cause your code to become less nimble and harder to read, are likely "evil". It also easy to waste time if you're trying to write optimal code for something you don't understand yet. But planning for good performance early on is not a bad idea. What are the things that need to happen in order for us to be able to work on this piece of software, in a manageable way, yet ensure that it won't end up as an incredibly sluggish final product? Those ad-hoc last-minute optimizations may not be enough.



-->



<h3>Game Engines</h3>
<p>When discussing game enginges with fellow game developers, I think it's too easy to come off as "elitist" for using "custom engines". I really don't think that is fair. First off, I think people sometimes over-estimate the difficulty of making your own "custom engine"-game. Libraries can do a lot for you! I don't think it's beyone anyone to make a game  using SDL or other similar libraies like that.</p>

<p>Secondly, C++ is simply the way I got started making games, in a time before Unity had gained massive popularity. It's like you've learned to write with your right hand, and now you have to re-learn it without your left. It leads to some frustration. I'm sure I could do it, but so far I've had no reason to jump over permanently, although I admit I am tempted.</p>
<p>It's not <i>"I'm so great that I don't even need Unity"</i>.<br>&emsp;
-"I'm too bad at Unity", would be closer to the truth.</p>

<!-- Having tried Unity and Godot a couple of times, it sure seems nice, and it has some cool features, but then I arrive at the problem of the type I already understand and have already solved a bunch of times with my regular tools, just I can't figure out how to solve it the way BigEninge(tm) wants you to. All while getting lost in the UI and drowning in the documentation.  -->


<p>I don't think there's anything wrong with wanting to know what's going on with the hardware, and trying your best to make as good software (in terms of runtime performance) as you can.</p>

<p>I'm not pretending I'm "better" than the development team over at Unity (especially not when it comes to making a big general purpose engine), but I do think it's the best route to take for the games I make, where it deals a lot with very specific techniques for rendering and physics.</p>


<p>That said, one of these day I think I will make the jump. What I'm describing here is just my current status. I would actually look forward to work on a higher level for a while. The 

It's not that I think "I'm so great that I need Unity", it's more like "I'm so Not Great that I Can' do it Withouth C+". It's 

  And it's only gotten easier lately with the rise of Single File Libraries for almost any purpose.</p> 
<p> 




</p> First of all, C++ was my first language, and I learned it before Unity and similar engines had gained popularity, so this is just the way I've been raised. It's not <i>"I'm so great that I don't need Unity"</i>. It's more like <i>"Unity looks pretty intimidating, I wonder how difficult it would be to do a lot of the things I know how to make in C++ in Unity..."</i></p>

<p>Being a low-level programmer doesn't mean I think I could do a better job than say, the big teams that work on Unity. Especially not for a general purpose game engine. It just means I want to do my best, in the best way I know how to, for my own software. I would say that sometimnes</p>

It's like you've learned how to draw with you

<p>It's simplest way to make games that do exactly what I want them to, that <b>I</b> know.</p> 



the things I want them to). And as a consumer I definitely don't hold the choise of engine against anyone  anyone</p>


 This is also <i>the way</i> I learned how to program, as C++ was my first language. It was, as far as I could tell at the time, the only way to make games that weren't restricted in one way or another.</p>



<h3>High level</h3>




<p>Programming to me, at least when I do it for myself, is not *just* about productivity. It's a learning experience as well. I want the deeper knowledge too. So I may spend an unreasonable amount of time ("prematurely") optimizing something that really isn't that important. , and you can call that premature optimization if you want to, but it's also fun to make things go fast.</p>



I understand very well that it can be a sinkhole in terms of time. Sometimes I deliberately spend more time than I should on something, simply because I view it as practize as well. 

<p>But sometimes I like to dive into some higher level project in Python or JavaScript, where I have very little knowledge about the low level. It can be a nice <i>vacation</i> sometimes, and great for productivity.</p>
  

it makes to the OS and how oftenin terms of how the code runs, 

"node" in install 5000 
long minimal dependencies. I don't like using too long bui




<h3>Other API's and Tools I use fairly often</h3>
<ul>
  <li>HTML/CSS, HTML5 Canvas, WebGL</li>
  <li>XML</li>
  <li>HTML, CSS, Canvas</li>
</ul>



</p>


<p>Yeah, that pretty much sums up what I use 99.9% of the time when programming.</p>

<p>I do sometimes use Git. When I have to. Maybe I'm missing out on something by not integrating a git-workflow into my brain. And again I'm reminded that I lack experience working in a big team on big software.Working alone on a tiny project, I have to say I still prefer "manually" typing "cp src backups/220829 -r" every now and then. It's simple. In other words I haven't integrated a Git workflow into my brain the way some people appears to have. Maybe I'm missing out. And again, I lack the experience of working on big software team. So why am I even bringing this up, ugh. </p>

<p>No, I don't always use version control. Typing "cp project backup/220830 -r" is simple and works. Dangerous?  Or doing it using Dired in emacs. Or just the OS file browser. Like... yes, I don't get automatic versioning, but typing in a date is also not much work. IDK. I think people get religious about this MINOR detail for no good reason.</p>



<h3>On language features</h3>
<p>Often when making games, I find the help a language can provide to be marginal, compared to the difficulty of the <i>real</i> problem itself. The logical problem, the math problem or the design problem. The type of problem I can spend an entire week thinking about - often has little to do with language.<br>
<p>But then... the source gets big. Past a point (20KLOC or so?) is where it gets so difficult to keep it all in your head, that a different way of programming becomes necessairy. I'm not talking about 1000LOC ->5000LOC, I'm talking about going from a well structured nicely written 20KLOC C  program, to 1MLOC and beyond. About that I couldn't tell you anything, because I've never been part of a big team working on big software. But my suspicion is that some language features that help to deal with the complexity is worth a lot. You know, Java and Go probably exists for reasons. </p>

  
<span style="padding-left:1.8em"/>Once I've learned enough of a language to use it, I'm a happy coder. The disagreement I may have with any language is, on the whole, not <i>that</i> bothersome. The bottleneck is more likely to be <b>me</b>. That's not to say the choice of tools when making something doesn't matter. Or that the tools couldn't be much better.</p>

<br>

<h3>Languages I use</h3>
<p><b>C</b> is my favorite language. It has many flaws. It might be the stockholm syndrome of having relied on it for so long. But there it is. I won't bore you with my rant on C. What could I say that hasn't been said by others so many times already. </p>
 <!-- <p>I use it because I know I can compile it anywhere and I don't need to set up big fat IDE or software suite to use it. <!-- I use it when I want more or less <i>exact</i> control over how a program behaves. Or when I just need low-level access. It has a limited set of features so it doesn't take up much headspace to use. It's abundant and it compiles quickly.  </p> -->

<p><b>C++</b> was the first language I learned, and one I still use a lot.


 My preference now would be to only use "the good parts" of the language(very subjective, and who doesn't. Rather, does *anyone* use ALL of C++? Is that even possible?</p>

<p>I tend to code C++ in a style not too remote from C. But if you're thinking of hiring me and now start to suspect that I wouldn't be able to work in your team because of C++ ideology, you're wrong about me being idealistic about it. I'd be happy to adapt. I know I have much to learn about working on bigger projects with big teams. <br>

  <span style="padding-left:1.8em"/>I sometimes make use of <b>STL</b> and a modern set of C++-features for some of my programs. I can see how looking at some std::thing() from &lt;algorithm&gt; could be less stressful than looking at the nested loops, you know, when your program reaches 100000 lines of code or so.  I'm happy to adapt and to try new things.</p>

<p style="color:#fda;"><b>Rust? Jai?</b> There are things I would want better help with that C and C++ really doesn't do well. Better control over memory layout, being able to move between <a href="https://en.wikipedia.org/wiki/AoS_and_SoA"><i>AoS and SoA</i></a> without a ton of struggle. Or not having vectorization messed up all the time for silly reasons.</p>
<br>
<p><b>Python</b> has lately come to replace some of my C++-written tools in some tasks, thanks to Blender (and the fact that I've been getting more familiar with both Python and Blender). When it's possible, it's nicer to just export to the final format directly, compared to first exporting as Collada or Wavefront or some other intermediary format, before processing it in a separate program.</p>

<p>I use <b>Javascript</b> for things like this website and the occasional browser game. I'm all for making games with HTML5 and WebGL. The site is written <i>purely</i> in Javascript, but if I continue to write as much web-code as I have been lately, I will have to find some better tools. I'm ogling Typescript for game development purposes.</p>

<p>I like <b>Lua</b>. With the rise of Fantasy Consoles such as Pico-8, I've spent a fair amount of time with the language. My <b>FC</b> of choice is <b><a href="https://tic.computer/">TIC-80</a></b>, for which I've made a bunch of 3D-demos. Additionally, I've embedded Lua into some of my game engines for scripting purposes.</p><!-- But now, I'm more interested in creating own tiny scripting language. A project I've started and gotten a fair bit into... to replace Lua...  been temped to desing my own language for that purpose.</p-->

<!--p>Using Emacs has mean writing macros in <b>Elisp</b> every now and then, but rarely enough that I've never gotten good at it. The same would go for a bunch of other languages I've dipped my toes into, out of curiosity (Rust,Haskell,Forth..) or temporary necessity (C#, Batch).</p-->

<p>Finally, I want to mention <b>Java</b>, which I used a lot from about 2010 up until 2014, but never since. As I'm sure is the case for most programmers, there have been many languages I've only dipped my toes into, out of curiosity (Rust,Haskell,Forth) or temporary necessity (Elisp, C#, GML, GDscript...).</p>

<h3>Programming environment</h3>
<p>I use <b>Emacs</b> for most editing tasks, or notepad++. I've also used MSVS, Eclipse and Code::Blocks. I'm comfy with the <b>GNU Compiler Collection</b> (including the debugger). Compiler Explorer (<a href="https://godbolt.org">godbolt.org</a>) is another tool I've had great use of, and fun poking around with. Some libraries and APIs I'm familiar with include <b>GLFW</b>, <b>SDL</b>, <b>OpenGL</b>, <b>Bullet</b> (physics), <b>TinyXML</b>,  <b>OpenAL</b>, <b>Vorbis</b>, <b>libpng</b>, <b>pthread</b> and <b>TinyCThread</b>.</p>
<br>



<p>You made it. Farewell!</p>
