<h1>Programming</h1>

<p>This page attempts to summarize me as a programmer. First off, to get it out of the way; the languages, tools and environments I use regularly:</p> 

<h3>Languages I use regularly</h3>
<p>
<ul>
  <li>C</li>
  <li>C++</li>
  <li>Python</li>
  <li>JavaScript</li>
  <li>Lua</li>
</ul>

<h3>Other tools</h3>
<ul>
  <li>Emacs</li>
  <li>Visual Studio</li>
  <li>GNU Compiler Collection</li>
  <li>CMake</li>
  <li>Bash</li>
</ul>

<h3>Libraries (C)</h3>
<ul>
  <li>OpenGL</li>
  <li>OpenAL</li>
  <li>GLFW</li>
  <li>Various Single Header Files</li>
</ul>


<h3>Reasons</h3>
<h3>Lowly beginnings</h3>
<p>Video games were a big driver for me to learn programming. They were magical things to me, and I wanted to understand them both on a low, high and artistic level. So I started out with <b>C++</b> which felt like the only viable option at the time (~2008) for making games. Soon after, I discovered the source code for Doom and other games written in <b>C</b>, which lead me to learn that language as well.<br>&emsp;
  Uncovering the mysteries and inner workings of games, and implementing a lot of it in my own games, has been a true joy.</p>

<p>To this day I still remain mostly on the low-level end of things. I want to know what's going with the hardware, what system-calls are being made, how much memory is used and what libraries are used. That the software I release is ballpark reasonable in terms of performance, in relation to the work that is being done. <br>&emsp;I like to work with a minimal set of dependencies, and prefer not to rely on big binary blobs or black boxes where I have no way of knowing what may be causing a problem.</p>
<p>But, I don't treat all projects the same and write plenty of code in a less pedantic way.</p>


<h3>High-level</h3>
<p>I don't need to explain the usefulness of Python and JavaScript. I'm not an expert at any of them, but I do use them a lot. JavaScript for anything that runs in a browser. Python mostly in combination with Blender 3D, for custom tools and plugins, but sometimes in for pure math/problem-solving situations.</p>

<h3>Scale</h3>

<p>I've made games with <b>Java</b> and <b>C#</b>, but honestly I don't have much to say about these languages.
<p>My biggest weakness as a programmer is probably my lack of experience working with a bigger team. I can see the value for a team in using a language that enforce a coding-style and prevents direct memory access etc., but for me as a lone coder, I don't run into the same complexity.<br>&emsp;
Sometimes I do run into some trouble as my code grows. I will say that I miss type-safety in Python.</p> 


<h3>Whatever is useful</h3>
<p>I care really little about syntax. As long as a language can do the basic things that are required, it's fine. The problem at hand is the important part, the logic, the algorithm, whatever it is, not the syntax. :)</p>



<p>This area of programming is probably my biggest weakness as a programmer. I simply don't have a lot of experience working with a bigger team. But 




touch memory directly. I can definitely see how this would be valuable for a big revolving-doors company. I have very little experience working in a team, so it doesn't really benefit me.</p -->

<p>As a mostly lone-wolf programmer, I'm not the biggest fan of the restrictive 
I'm talking about Java and Go here. And I'm sure this part is valuable for big programming teams. 

, but honestly I have limited experience working in big teams. But , but honestly I have limited experience working in big teams. But 


  I could definietly see it as a benefit if my next door coder was prevented from writing absolutely unreadably 

where I have some scripts and tools Java, where don't care about what goes on under the hood. I don't really need to explain why these things are useful. I'm not an expert at any of them, but I get a lot out of them. In particular Python in combination with Blender 3D.
<br>&emsp;I've used Lua as an embedded scripting langauge in some of my projects, but the greatest use of it recently that has been with the rise of the <a href="/proj/tic80.html">fantasy consoles</a>.</p>

<p>I've also used JavaScript as well as Java to make games.


<h3>Whatever is useful</h3>
<p>For all of these high-level languages, the language itself feels much less important than the problem at hand. Understanding the logic, the algorithm, the function of it, is the important part, not syntax. I'm happy to pick up and use anything. :)</p>





<h3>Math, Algorithms, Abstract Types and Data-Structures</h3>
<p>While I like to know the limits of the hardware I'm working on, these parts are at least as important. Very often everything is intertwined. You may implement the abstract type using a data-structure tweaked to work  within the constraints of the hardware. Your algorithm may pick a different 

with a design that suirs the data-structure based on the hardware



thethe 
on These things are THE MOST interesting part of is is THE MOST interest<p>The mathematics for 3D-rendering and is amazingly interesting, but since this page is about programming I'll end the rant astuff 


<p>I'm genuinely interested in knowing what's going on with the software, and the limitations of the hardware.</p>




<h3>Game Engines</h3>
<p>When discussing game enginges with fellow game developers, I think it's too easy to come off as "elitist" for using "custom engines". I really don't think that is fair. First off, I think people sometimes over-estimate the difficulty of making your own "custom engine"-game. Libraries can do a lot for you! I don't think it's beyone anyone to make a game  using SDL or other similar libraies like that.</p>


<p>Secondly, C++ is simply the way I got started making games, in a time before Unity had gained massive popularity. It's like you've learned to write with your right hand, and now you have to re-learn it without your left. It leads to some frustration. I'm sure I could do it, but so far I've had no reason to jump over permanently, although I admit I am tempted.</p>
<p>It's not <i>"I'm so great that I don't even need Unity"</i>.<br>&emsp;
-"I'm too bad at Unity", would be closer to the truth.</p>

<!-- Having tried Unity and Godot a couple of times, it sure seems nice, and it has some cool features, but then I arrive at the problem of the type I already understand and have already solved a bunch of times with my regular tools, just I can't figure out how to solve it the way BigEninge(tm) wants you to. All while getting lost in the UI and drowning in the documentation.  -->


<p>I don't think there's anything wrong with wanting to know what's going on with the hardware, and trying your best to make as good software (in terms of runtime performance) as you can.</p>
<p>I'm not pretending I'm "better" than the development team over at Unity (especially not when it comes to making a big general purpose engine), but I do think it's the best route to take for the games I make, where it deals a lot with very specific techniques for rendering and physics.</p>



<p>That said, one of these day I think I will make the jump. What I'm describing here is just my current status. I would actually look forward to work on a higher level for a while. The 

It's not that I think "I'm so great that I need Unity", it's more like "I'm so Not Great that I Can' do it Withouth C+". It's 

  And it's only gotten easier lately with the rise of Single File Libraries for almost any purpose.</p> 

<p> 




</p> First of all, C++ was my first language, and I learned it before Unity and similar engines had gained popularity, so this is just the way I've been raised. It's not <i>"I'm so great that I don't need Unity"</i>. It's more like <i>"Unity looks pretty intimidating, I wonder how difficult it would be to do a lot of the things I know how to make in C++ in Unity..."</i></p>

<p>Being a low-level programmer doesn't mean I think I could do a better job than say, the big teams that work on Unity. Especially not for a general purpose game engine. It just means I want to do my best, in the best way I know how to, for my own software. I would say that sometimnes</p>

It's like you've learned how to draw with you

<p>It's simplest way to make games that do exactly what I want them to, that <b>I</b> know.</p> 



the things I want them to). And as a consumer I definitely don't hold the choise of engine against anyone  anyone</p>


 This is also <i>the way</i> I learned how to program, as C++ was my first language. It was, as far as I could tell at the time, the only way to make games that weren't restricted in one way or another.</p>



<h3>High level</h3>




<p>Programming to me, at least when I do it for myself, is not *just* about productivity. It's a learning experience as well. I want the deeper knowledge too. So I may spend an unreasonable amount of time ("prematurely") optimizing something that really isn't that important. , and you can call that premature optimization if you want to, but it's also fun to make things go fast.</p>



I understand very well that it can be a sinkhole in terms of time. Sometimes I deliberately spend more time than I should on something, simply because I view it as practize as well. 

<p>But sometimes I like to dive into some higher level project in Python or JavaScript, where I have very little knowledge about the low level. It can be a nice <i>vacation</i> sometimes, and great for productivity.</p>
  

it makes to the OS and how oftenin terms of how the code runs, 

"node" in install 5000 
long minimal dependencies. I don't like using too long bui




<h3>Other API's and Tools I use fairly often</h3>
<ul>
  <li>HTML/CSS, HTML5 Canvas, WebGL</li>
  <li>XML</li>
  <li>HTML, CSS, Canvas</li>
</ul>



</p>


<p>Yeah, that pretty much sums up what I use 99.9% of the time when programming.</p>

<p>I do sometimes use Git. When I have to. Maybe I'm missing out on something by not integrating a git-workflow into my brain. And again I'm reminded that I lack experience working in a big team on big software.Working alone on a tiny project, I have to say I still prefer "manually" typing "cp src backups/220829 -r" every now and then. It's simple. In other words I haven't integrated a Git workflow into my brain the way some people appears to have. Maybe I'm missing out. And again, I lack the experience of working on big software team. So why am I even bringing this up, ugh. </p>

<p>No, I don't always use version control. Typing "cp project backup/220830 -r" is simple and works. Dangerous?  Or doing it using Dired in emacs. Or just the OS file browser. Like... yes, I don't get automatic versioning, but typing in a date is also not much work. IDK. I think people get religious about this MINOR detail for no good reason.</p>



<h3>On language features</h3>
<p>Often when making games, I find the help a language can provide to be marginal, compared to the difficulty of the <i>real</i> problem itself. The logical problem, the math problem or the design problem. The type of problem I can spend an entire week thinking about - often has little to do with language.<br>
<p>But then... the source gets big. Past a point (20KLOC or so?) is where it gets so difficult to keep it all in your head, that a different way of programming becomes necessairy. I'm not talking about 1000LOC ->5000LOC, I'm talking about going from a well structured nicely written 20KLOC C  program, to 1MLOC and beyond. About that I couldn't tell you anything, because I've never been part of a big team working on big software. But my suspicion is that some language features that help to deal with the complexity is worth a lot. You know, Java and Go probably exists for reasons. </p>

  
<span style="padding-left:1.8em"/>Once I've learned enough of a language to use it, I'm a happy coder. The disagreement I may have with any language is, on the whole, not <i>that</i> bothersome. The bottleneck is more likely to be <b>me</b>. That's not to say the choice of tools when making something doesn't matter. Or that the tools couldn't be much better.</p>

<br>

<h3>Languages I use</h3>
<p><b>C</b> is my favorite language. It has many flaws. It might be the stockholm syndrome of having relied on it for so long. But there it is. I won't bore you with my rant on C. What could I say that hasn't been said by others so many times already. </p>
 <!-- <p>I use it because I know I can compile it anywhere and I don't need to set up big fat IDE or software suite to use it. <!-- I use it when I want more or less <i>exact</i> control over how a program behaves. Or when I just need low-level access. It has a limited set of features so it doesn't take up much headspace to use. It's abundant and it compiles quickly.  </p> -->

<p><b>C++</b> was the first language I learned, and one I still use a lot.


 My preference now would be to only use "the good parts" of the language(very subjective, and who doesn't. Rather, does *anyone* use ALL of C++? Is that even possible?</p>

<p>I tend to code C++ in a style not too remote from C. But if you're thinking of hiring me and now start to suspect that I wouldn't be able to work in your team because of C++ ideology, you're wrong about me being idealistic about it. I'd be happy to adapt. I know I have much to learn about working on bigger projects with big teams. <br>

  <span style="padding-left:1.8em"/>I sometimes make use of <b>STL</b> and a modern set of C++-features for some of my programs. I can see how looking at some std::thing() from &lt;algorithm&gt; could be less stressful than looking at the nested loops, you know, when your program reaches 100000 lines of code or so.  I'm happy to adapt and to try new things.</p>

<p style="color:#fda;"><b>Rust? Jai?</b> There are things I would want better help with that C and C++ really doesn't do well. Better control over memory layout, being able to move between <a href="https://en.wikipedia.org/wiki/AoS_and_SoA"><i>AoS and SoA</i></a> without a ton of struggle. Or not having vectorization messed up all the time for silly reasons.</p>
<br>
<p><b>Python</b> has lately come to replace some of my C++-written tools in some tasks, thanks to Blender (and the fact that I've been getting more familiar with both Python and Blender). When it's possible, it's nicer to just export to the final format directly, compared to first exporting as Collada or Wavefront or some other intermediary format, before processing it in a separate program.</p>

<p>I use <b>Javascript</b> for things like this website and the occasional browser game. I'm all for making games with HTML5 and WebGL. The site is written <i>purely</i> in Javascript, but if I continue to write as much web-code as I have been lately, I will have to find some better tools. I'm ogling Typescript for game development purposes.</p>

<p>I like <b>Lua</b>. With the rise of Fantasy Consoles such as Pico-8, I've spent a fair amount of time with the language. My <b>FC</b> of choice is <b><a href="https://tic.computer/">TIC-80</a></b>, for which I've made a bunch of 3D-demos. Additionally, I've embedded Lua into some of my game engines for scripting purposes.</p><!-- But now, I'm more interested in creating own tiny scripting language. A project I've started and gotten a fair bit into... to replace Lua...  been temped to desing my own language for that purpose.</p-->

<!--p>Using Emacs has mean writing macros in <b>Elisp</b> every now and then, but rarely enough that I've never gotten good at it. The same would go for a bunch of other languages I've dipped my toes into, out of curiosity (Rust,Haskell,Forth..) or temporary necessity (C#, Batch).</p-->

<p>Finally, I want to mention <b>Java</b>, which I used a lot from about 2010 up until 2014, but never since. As I'm sure is the case for most programmers, there have been many languages I've only dipped my toes into, out of curiosity (Rust,Haskell,Forth) or temporary necessity (Elisp, C#, GML, GDscript...).</p>

<h3>Programming environment</h3>
<p>I use <b>Emacs</b> for most editing tasks, or notepad++. I've also used MSVS, Eclipse and Code::Blocks. I'm comfy with the <b>GNU Compiler Collection</b> (including the debugger). Compiler Explorer (<a href="https://godbolt.org">godbolt.org</a>) is another tool I've had great use of, and fun poking around with. Some libraries and APIs I'm familiar with include <b>GLFW</b>, <b>SDL</b>, <b>OpenGL</b>, <b>Bullet</b> (physics), <b>TinyXML</b>,  <b>OpenAL</b>, <b>Vorbis</b>, <b>libpng</b>, <b>pthread</b> and <b>TinyCThread</b>.</p>
<br>



<p>You made it. Farewell!</p>
