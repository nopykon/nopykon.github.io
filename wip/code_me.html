<h2>About me as a programmer</h2>
<p>This section that attempts to briefly summarize me as a programmer. First off, to get it out of the way:</p>

<h4>Languages I use regularly</h4>
<p>
<ul>
  <li>C</li>
  <li>C++</li>
  <li>Python</li>
  <li>JavaScript</li>
  <li>Lua</li>
</ul>

<h4>Other tools</h4>
<ul>
  <li>GNU Compiler Collection</li>
  <li>CMake</li>
  <li>Emacs</li>
  <li>Visual Studio</li>
  <li>Git (but not religiously)</li>
  <li>Bash</li>
</ul>

<h4>Libraries</h4>
<ul>
  <li>GLFW, OpenGL, OpenAL - for my natively run games</li>
  <li>stb and other single file libraries - for use everywhere in C/C++ land.</li>
  <li>Bullet, Box2D - while I like to roll my own physics engines, I have used these libraries quite a bit as well.</li>
  <li>WebGL, HTML5 Canvas - I'm very unhip when it comes to the web, but I do like to make games that run in browsers. </li>
</ul>


<h3>C, C++ and Game Development</h3>
<p>C++ was my first programming language. I learned the basics in school and after that it felt like the only viable option (in 2008) for making games. Soon after, I discovered the source code for Doom and other games written in <b>C</b>, which led me to learn that language as well.
 <br>&emsp;Needless to say, video games have been a big driver for me to learn programming. I wanted to understand them on a low and high, as well as artistic level. 
  Uncovering the mysteries and inner workings of games, and implementing a lot of it in my own games, has been a true joy.</p>

<p>To this day I still remain mostly on the low-level end of things. Of course not all the way down to bare metal, but I do look at generated assembly quite often (Godbolt rules, I should almost add it among the tools at the top!) to make sure things are compiled the way I want them to. I want to know what's going on with the hardware, what system-calls are being made, how much memory is used and what libraries are used. That the software I release is ballpark reasonable in terms of performance, in relation to the work that is being done. <br>&emsp;I like to work with a minimal set of dependencies, and prefer not to rely on big binary blobs or black boxes where I have no way of knowing what may be causing a problem.</p>


<p>I write C and C++ in a similar way. Some might call my C++ "orthodox". I'll use complex types where necessairy, but most of the time simple arrays of simple structs will do. I'm not afraid of raw pointers, but I also like it when things are trivially copyable (without serialization etc). I use inheritance in moderation and yes I am a student of Data-Oriented Design.</p>

<!-- p>Obviously I don't write all my code in C/C++. There are plenty of scenarios where I'll use something more relaxed and less pedantic.</p -->

<h4>Scripting</h4>
<p>I don't need to explain the usefulness of <b>Python</b> and <b>JavaScript</b>. I do use them a lot. JavaScript for anything that runs in a browser. Python mostly in combination with Blender 3D for custom scripts, but sometimes for pure math/puzzle-solving. I do miss the type-safety, and with Python I miss the ability to just brute force loop thought some things and not have it take several seconds (where it would  happen in the blink of an eye in C). I know of Numba JIT. Having tried it I concluded that for me, when performance is required, it's just easier to use C++ instead.</p>

<p><b>Lua</b> is language I've embedded into some of my C++ software projects, as well as make games with in Love2D and TIC-80. It's small, fast and fun to program in. What's not to like?</p>

<p><b><i>The Seal Programming Language</i></b> is <i>yet another</i> scripting language, one that I have created to amuze myself, and to learn. Writing the compiler sure has thought me a few lessons. The focus of the language isn't on syntax or style, but on practicality as an emebedded language. The runtime state use very little memory, in a single block, that you can copy to a different memory location (<i>trivially</i>) and then continue to run as if nothing happened. A detailed write-up should happen once I've dealt with a few more bugs...</p>


<h4>Enterprise</h4>
<p>I've made small games with <b>Java</b> and <b>C#</b>, and it worked well, but honestly I don't have much more to say about these languages. My biggest weakness as a programmer may be my lack of experience working with bigger teams on bigger projects. I do find some of the "big corp" practices silly, but even so, I understand the need for safer and more restrictive languages, and could see myself picking one up again in the future.

<h3>Math and Algorithms</h3>
<p>So much of the magic behind games, and the joy of figuring out how they work, lies in the math and algorithms. <!-- This knowledge is much more powerful than the syntax of any language.--></p> 
<p>I've studied and implemented various algorithms related to game-AI, rendering and collision detection, such as GJK, Bresnham, Dijkstra, A*, Median-Cut, Cohen-Sutherland and Sutherland-Hodgman. I've also implemented many abstract types using various data-structures in C and C++.</p>

<p>I don't have a background in Math, but I've picked up a lot of Linear Algebra and some Calculus writing games and physics engines. When it's for some some "serious math" (by my standards), Desmos graphing calculatior goes up often enought that I should perhaps add it to the list of oftenly used tools.</p>
<br>
<br>
<br>
<p>Well, hopefully by now you have some idea of what kind of programming creature I am.</p>
<div style="text-align:right;">
<p>Bye!</p>
</div>
